// ques1
#include <iostream>
using namespace std;
#define MAX 5   
class Stack {
    int arr[MAX];
    int top;

public:
    Stack() {
        top = -1;   // Initially stack is empty
    }

    // Function to push element
    void push(int x) {
        if (isFull()) {
            cout << "Stack Overflow! Cannot push " << x << endl;
        } else {
            arr[++top] = x;
            cout << x << " pushed into stack." << endl;
        }
    }

    // Function to pop element
    void pop() {
        if (isEmpty()) {
            cout << "Stack Underflow! Nothing to pop." << endl;
        } else {
            cout << arr[top--] << " popped from stack." << endl;
        }
    }

    // Function to check if stack is empty
    bool isEmpty() {
        return (top == -1);
    }

    // Function to check if stack is full
    bool isFull() {
        return (top == MAX - 1);
    }

    // Function to display stack
    void display() {
        if (isEmpty()) {
            cout << "Stack is Empty!" << endl;
        } else {
            cout << "Stack elements (top to bottom): ";
            for (int i = top; i >= 0; i--) {
                cout << arr[i] << " ";
            }
            cout << endl;
        }
    }

    // Function to see top element
    void peek() {
        if (isEmpty()) {
            cout << "Stack is Empty!" << endl;
        } else {
            cout << "Top element is: " << arr[top] << endl;
        }
    }
};

int main() {
    Stack s;
    int choice, value;

    do {
        cout << "\n--- Stack Menu ---\n";
        cout << "1. Push\n";
        cout << "2. Pop\n";
        cout << "3. Check if Empty\n";
        cout << "4. Check if Full\n";
        cout << "5. Display\n";
        cout << "6. Peek (Top Element)\n";
        cout << "7. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter value to push: ";
            cin >> value;
            s.push(value);
            break;
        case 2:
            s.pop();
            break;
        case 3:
            if (s.isEmpty())
                cout << "Stack is Empty." << endl;
            else
                cout << "Stack is not Empty." << endl;
            break;
        case 4:
            if (s.isFull())
                cout << "Stack is Full." << endl;
            else
                cout << "Stack is not Full." << endl;
            break;
        case 5:
            s.display();
            break;
        case 6:
            s.peek();
            break;
        case 7:
            cout << "Exiting program." << endl;
            break;
        default:
            cout << "Invalid choice! Try again." << endl;
        }
    } while (choice != 7);

    return 0;
}



// ques2
#include <iostream>
#include <stack>
using namespace std;

int main() {
    string str, reversed;
    cout << "Enter a string: ";
    cin >> str;

    stack<char> s;

    // Push all characters into stack
    for (char ch : str) {
        s.push(ch);
    }

    // Pop characters from stack to get reversed string
    while (!s.empty()) {
        reversed += s.top();
        s.pop();
    }

    cout << "Reversed string: " << reversed << endl;
    return 0;
}



//ques 3
#include <stdio.h>
#include <string.h>

#define MAX 100
char stack[MAX];
int top = -1;

void push(char c) {
    if (top < MAX - 1) {
        stack[++top] = c;
    }
}

char pop() {
    if (top >= 0) {
        return stack[top--];
    }
    return '\0';
}

int isMatchingPair(char open, char close) {
    return (open == '(' && close == ')') ||
           (open == '{' && close == '}') ||
           (open == '[' && close == ']');
}

int isBalanced(char expr[]) {
    for (int i = 0; i < strlen(expr); i++) {
        char ch = expr[i];
        
        if (ch == '(' || ch == '{' || ch == '[') {
            push(ch);
        } 
        else if (ch == ')' || ch == '}' || ch == ']') {
            if (top == -1) {
                return 0; // No matching opening bracket
            }
            char popped = pop();
            if (!isMatchingPair(popped, ch)) {
                return 0; // Mismatch
            }
        }
    }
    return top == -1; // If stack is empty → balanced
}

int main() {
    char expr[MAX];

    printf("Enter an expression: ");
    scanf("%s", expr);

    if (isBalanced(expr)) {
        printf("Balanced\n");
    } else {
        printf("Not Balanced\n");
    }

    return 0;
}



//ques4
#include <stdio.h>
#include <ctype.h>  

#define MAX 100

char stack[MAX];
int top = -1;

// Stack functions
void push(char c) {
    if (top < MAX - 1) {
        stack[++top] = c;
    }
}

char pop() {
    if (top >= 0) {
        return stack[top--];
    }
    return '\0';
}

char peek() {
    if (top >= 0) {
        return stack[top];
    }
    return '\0';
}

// Function to return precedence of operators
int precedence(char op) {
    switch (op) {
        case '^': return 3;
        case '*': case '/': return 2;
        case '+': case '-': return 1;
        default: return 0;
    }
}

// Function to check if operator is right-associative
int isRightAssociative(char op) {
    return (op == '^');  // ^ is right-associative
}

// Infix to Postfix conversion
void infixToPostfix(char infix[]) {
    char postfix[MAX];
    int i = 0, j = 0;
    char ch;

    while ((ch = infix[i++]) != '\0') {
        // Operand → directly add to output
        if (isalnum(ch)) {
            postfix[j++] = ch;
        }
        // Opening parenthesis → push
        else if (ch == '(') {
            push(ch);
        }
        // Closing parenthesis → pop until '('
        else if (ch == ')') {
            while (top != -1 && peek() != '(') {
                postfix[j++] = pop();
            }
            pop(); // remove '('
        }
        // Operator
        else {
            while (top != -1 && precedence(peek()) > 0 &&
                   (precedence(peek()) > precedence(ch) ||
                   (precedence(peek()) == precedence(ch) && !isRightAssociative(ch)))) {
                postfix[j++] = pop();
            }
            push(ch);
        }
    }

    // Pop remaining operators
    while (top != -1) {
        postfix[j++] = pop();
    }

    postfix[j] = '\0';
    printf("Postfix Expression: %s\n", postfix);
}

// Main function
int main() {
    char infix[MAX];

    printf("Enter an infix expression: ");
    scanf("%s", infix);

    infixToPostfix(infix);

    return 0;
}


//ques5
#include <stdio.h>
#include <ctype.h>  // 

#define MAX 100

int stack[MAX];
int top = -1;

void push(int x) {
    if (top < MAX - 1) {
        stack[++top] = x;
    }
}

int pop() {
    if (top >= 0) {
        return stack[top--];
    }
    return 0;
}

// Function to evaluate a postfix expression
int evaluatePostfix(char expr[]) {
    int i = 0;
    char ch;
    int val1, val2;

    while ((ch = expr[i++]) != '\0') {
        if (isdigit(ch)) {
            // Convert char digit to int and push
            push(ch - '0');
        }
        else {
            // Pop two operands
            val2 = pop();
            val1 = pop();

            switch (ch) {
                case '+': push(val1 + val2); break;
                case '-': push(val1 - val2); break;
                case '*': push(val1 * val2); break;
                case '/': push(val1 / val2); break;
                case '^': {
                    int result = 1;
                    for (int j = 0; j < val2; j++) result *= val1;
                    push(result);
                    break;
                }
            }
        }
    }
    return pop();  // Final result
}

int main() {
    char postfix[MAX];

    printf("Enter a postfix expression (single-digit operands): ");
    scanf("%s", postfix);

    printf("Result = %d\n", evaluatePostfix(postfix));

    return 0;
}

