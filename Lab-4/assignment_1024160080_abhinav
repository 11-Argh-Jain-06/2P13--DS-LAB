// Ques1:- Develop a menu driven program demonstrating the following operations on simple Queues:
// 1.enqueue()
// 2. dequeue()
// 3. isEmpty()
// 4. isFull()
// 5. display()
// 6. peek().
#include <iostream>
using namespace std;
#define MAX 5
int queue[MAX];
int front = -1;
int rear = -1;
void enqueue(int value) {
    if (rear == MAX - 1) {
        cout << "Queue is full" << endl;
    } else {
        if (front == -1) front = 0;
        rear++;
        queue[rear] = value;
        cout << value << " enqueued to queue" << endl;
    }
}
int dequeue() {
    if (front == -1 || front > rear) {
        cout << "Queue is empty" << endl;
        return -1;
    } else {
        int value = queue[front];
        front++;
        cout << value << " dequeued from queue" << endl;
        return value;
    }
}
bool isEmpty() {
    return front == -1 || front > rear;
}
bool isFull() {
    return rear == MAX - 1;
}
void display() {
    if (isEmpty()) {
        cout << "Queue is empty" << endl;
    } else {
        cout << "Queue elements: ";
        for (int i = front; i <= rear; i++) {
            cout << queue[i] << " ";
        }
        cout << endl;
    }
}
int peek() {
    if (isEmpty()) {
        cout << "Queue is empty" << endl;
        return -1;
    } else {
        return queue[front];
    }
}
int main() {
    int choice, value;
    do {
        cout << "Menu:\n1. Enqueue\n2. Dequeue\n3. Is Empty\n4. Is Full\n5. Display\n6. Peek\n7. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;
        switch (choice) {
            case 1:
                cout << "Enter value to enqueue: ";
                cin >> value;
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                if (isEmpty()) cout << "Queue is empty" << endl;
                else cout << "Queue is not empty" << endl;
                break;
            case 4:
                if (isFull()) cout << "Queue is full" << endl;
                else cout << "Queue is not full" << endl;
                break;
            case 5:
                display();
                break;
            case 6:
                value = peek();
                if (value != -1) cout << "Front element is: " << value << endl;
                break;
            case 7:
                cout << "Exiting..." << endl;
                break;
            default:
                cout << "Invalid choice, please try again." << endl;
        }
    } while (choice != 7);
    return 0;
}


// Ques2:- Develop a menu driven program demonstrating the following operations on Circular Queues: 
// 1. enqueue()
// 2. dequeue()
// 3. isEmpty() 
// 4. isFull()
// 5. display()
// 6. peek().
#include <iostream>
using namespace std;
#define MAX 5
int queue[MAX];
int front = -1;
int rear = -1;

void enqueue(int value) {
    if ((rear + 1) % MAX == front) {
        cout << "Queue is full" << endl;
    } else {
        if (front == -1) front = 0;
        rear = (rear + 1) % MAX;
        queue[rear] = value;
        cout << value << " enqueued to queue" << endl;
    }
}
int dequeue() {
    if (front == -1) {
        cout << "Queue is empty" << endl;
        return -1;
    } else {
        int value = queue[front];
        if (front == rear) {
            front = -1;
            rear = -1;
        } else {
            front = (front + 1) % MAX;
        }
        cout << value << " dequeued from queue" << endl;
        return value;
    }
}
bool isEmpty() {
    return front == -1;
}
bool isFull() {
    return (rear + 1) % MAX == front;
}
void display() {
    if (isEmpty()) {
        cout << "Queue is empty" << endl;
    } else {
        cout << "Queue elements: ";
        int i = front;
        while (true) {
            cout << queue[i] << " ";
            if (i == rear) break;
            i = (i + 1) % MAX;
        }
        cout << endl;
    }
}
int peek() {
    if (isEmpty()) {
        cout << "Queue is empty" << endl;
        return -1;
    } else {
        return queue[front];
    }
}
int main() {
    int choice, value;
    do {
        cout << "\nMenu:\n";
        cout << "1. Enqueue\n";
        cout << "2. Dequeue\n";
        cout << "3. Is Empty\n";
        cout << "4. Is Full\n";
        cout << "5. Display\n";
        cout << "6. Peek\n";
        cout << "7. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;
        switch (choice) {
            case 1:
                cout << "Enter value to enqueue: ";
                cin >> value;
                enqueue(value);
                break;
            case 2:
                dequeue();
                break;
            case 3:
                if (isEmpty()) cout << "Queue is empty" << endl;
                else cout << "Queue is not empty" << endl;
                break;
            case 4:
                if (isFull()) cout << "Queue is full" << endl;
                else cout << "Queue is not full" << endl;
                break;
            case 5:
                display();
                break;
            case 6:
                value = peek();
                if (value != -1) cout << "Front element is: " << value << endl;
                break;
            case 7:
                cout << "Exiting..." << endl;
                break;
            default:
                cout << "Invalid choice, please try again." << endl;
        }
    } while (choice != 7);
    return 0;
}


// Ques3:-Write a program interleave the first half of the queue with second half. 
// Sample I/P: 4 7 11 20 5 9 Sample O/P: 4 20 7 5 11 9

#include <iostream>
#include <queue>
using namespace std;
void interleaveQueue(queue<int>& q) {
    if (q.size() % 2 != 0) {
        cout << "Queue size must be even to interleave." << endl;
        return;
    }
    int halfSize = q.size() / 2;
    queue<int> firstHalf, secondHalf;

    for (int i = 0; i < halfSize; i++) {
        firstHalf.push(q.front());
        q.pop();
    }
    while (!q.empty()) {
        secondHalf.push(q.front());
        q.pop();
    }
    while (!firstHalf.empty() && !secondHalf.empty()) {
        q.push(firstHalf.front());
        firstHalf.pop();
        q.push(secondHalf.front());
        secondHalf.pop();
    }
}

int main() {
    queue<int> q;
    int n, element;
    cout << "Enter the number of elements (even number): ";
    cin >> n;
    if (n % 2 != 0) {
        cout << "Please enter an even number." << endl;
        return 1;
    }
    cout << "Enter the elements of the queue: ";
    for (int i = 0; i < n; i++) {
        cin >> element;
        q.push(element);
    }
    interleaveQueue(q);
    cout << "Interleaved Queue: ";
    while (!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    cout << endl;
    return 0;
}


// Ques4:-Write a program to find first non-repeating character in a string using Queue. 
// Sample I/P: a a b c Sample O/P: a -1 b b
#include <iostream>
#include <queue>
using namespace std;

void printFirstNonRepeating(string s) {
    queue<char> q;
    int freq[256] = {0};

    cout << "Output: ";
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == ' ') continue; 

        char ch = s[i];
        freq[ch]++;

        q.push(ch);

        
        while (!q.empty() && freq[q.front()] > 1) {
            q.pop();
        }

        if (q.empty())
            cout << "-1 ";
        else
            cout << q.front() << " ";
    }
    cout << endl;
}

int main() {
    string s;
    cout << "Enter the string (characters separated by space): ";
    getline(cin, s);

    printFirstNonRepeating(s);

    return 0;
}


// Ques5:- Write a program to implement a stack using 
// (a) Two queues and 
#include <iostream>
#include <queue>
using namespace std;

queue<int> q1, q2;

void push(int x) {
    q2.push(x);

    
    while (!q1.empty()) {
        q2.push(q1.front());
        q1.pop();
    }

    
    swap(q1, q2);
}

void pop() {
    if (q1.empty()) {
        cout << "Stack Underflow!" << endl;
        return;
    }
    cout << "Popped: " << q1.front() << endl;
    q1.pop();
}

void top() {
    if (q1.empty()) {
        cout << "Stack is empty!" << endl;
        return;
    }
    cout << "Top Element: " << q1.front() << endl;
}

void display() {
    if (q1.empty()) {
        cout << "Stack is empty!" << endl;
        return;
    }
    queue<int> temp = q1;
    cout << "Stack Elements (Top to Bottom): ";
    while (!temp.empty()) {
        cout << temp.front() << " ";
        temp.pop();
    }
    cout << endl;
}

int main() {
    cout << "Stack using Two Queues:\n";
    push(10);
    push(20);
    push(30);
    display();  

    top();      
    pop();      
    display();  
    return 0;
}

// (b) One Queue.

#include <iostream>
#include <queue>
using namespace std;

queue<int> q;

void push1(int x) {
    int size = q.size();
    q.push(x);

    
    for (int i = 0; i < size; i++) {
        q.push(q.front());
        q.pop();
    }
}

void pop1() {
    if (q.empty()) {
        cout << "Stack Underflow!" << endl;
        return;
    }
    cout << "Popped: " << q.front() << endl;
    q.pop();
}

void top1() {
    if (q.empty()) {
        cout << "Stack is empty!" << endl;
        return;
    }
    cout << "Top Element: " << q.front() << endl;
}

void display1() {
    if (q.empty()) {
        cout << "Stack is empty!" << endl;
        return;
    }
    queue<int> temp = q;
    cout << "Stack Elements (Top to Bottom): ";
    while (!temp.empty()) {
        cout << temp.front() << " ";
        temp.pop();
    }
    cout << endl;
}

int main() {
    cout << "\nStack using One Queue:\n";
    push1(10);
    push1(20);
    push1(30);
    display1();  

    top1();      
    pop1();      
    display1();  
    return 0;
}
